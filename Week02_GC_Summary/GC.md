## Serial

新生代垃圾收集器，采用标记-复制算法，特点是单线程工作，且工作时，必定发生 STW，但是其占用内存小，在单核环境里表现最好

## ParNew

多线程版本的 Serial，但它的运行垃圾收集的线程和运行用户代码的线程是可以并发执行的，在多核环境里可以取代 Serial

## Parallel Scavenge

类似 ParNew，但关注点是吞吐量的可控，即通过参数设定垃圾收集的目标，此外还支持 JVM 自适应调节目标，实质是多个工作线程一起进行垃圾收集

## Serial Old

老年代垃圾收集器版的 Serial，采用标记-整理算法，常与 Serial 搭配，在单核环境运行

## Parallel Old

老年代垃圾收集器版的 Parallel Scavenge，采用标记-整理算法，常与 Parallel Scavenge 搭配在多核环境下实现吞吐量优先的垃圾收集策略

## CMS

老年代垃圾收集器，采用标记-清除算法，关注点是停顿时间，堆内存在 4 - 6 GB 左右，可以考虑，常与 ParNew 搭配在多核环境下实现响应速度优先的垃圾收集策略

## Garbage First

混合收集器，采用标记-复制和标记-整理算法，关注停顿时间和吞吐量的可控性，堆内存大于 6 GB，可以考虑

## ZGC

类似 G1，硬件和 JDK 版本能够掌控且较新，堆内存比较大，比如几百GB，甚至 TB 级别的，又有低延迟需求，可以考虑，不过目前还是实验性阶段

## Shenandoah

类似 G1，如果使用的是 OpenJDK，可以考虑